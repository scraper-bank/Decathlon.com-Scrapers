/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
puppeteer.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'decathlon_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_SERVER = 'residential-proxy.scrapeops.io';
const PROXY_PORT = '8181';
const PROXY_USERNAME = 'scrapeops';
const PROXY_PASSWORD = API_KEY;

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1, // EXACT VALUE FROM TEMPLATE
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const html = $.html();

        const stripHTML = (h) => {
            if (!h) return "";
            return h.replace(/<[^>]*>/g, " ").trim();
        };

        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://www.decathlon.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            if (!priceText) return "USD";
            const upper = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD"
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (upper.includes(code)) return currency;
            }
            return "USD";
        };

        const cleanFloat = (s) => {
            if (!s) return 0;
            const match = s.replace(/,/g, "").match(/[\d,]+\.?\d*/);
            return match ? parseFloat(match[0]) : 0;
        };

        // JSON-LD Extraction
        let jsonLD = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const items = Array.isArray(data) ? data : [data];
                for (const item of items) {
                    if (item['@type'] === 'Product' || item['@type'] === 'ProductGroup') {
                        jsonLD = item;
                    }
                }
            } catch (e) {}
        });

        // Variant Selects Data
        let variantData = null;
        const variantScript = $("variant-selects script[type='application/json']").first();
        if (variantScript.length > 0) {
            try {
                variantData = JSON.parse(variantScript.text());
            } catch (e) {}
        }

        const outputData = {};

        // Aggregate Rating
        const aggRating = {
            bestRating: 5,
            worstRating: 1,
            ratingValue: 0,
            reviewCount: 0
        };
        let ratingVal = cleanFloat($("#averageRating").text());
        if (ratingVal === 0) {
            ratingVal = cleanFloat($(".rating-text span").first().text());
        }
        aggRating.ratingValue = ratingVal;
        const reviewCountStr = $(".rating-count span").text();
        aggRating.reviewCount = Math.floor(cleanFloat(reviewCountStr));
        outputData.aggregateRating = aggRating;

        // Availability
        let avail = "out_of_stock";
        if (variantData && variantData.available === true) {
            avail = "in_stock";
        } else if (html.toLowerCase().includes("instock") || html.toLowerCase().includes("in stock")) {
            avail = "in_stock";
        }
        outputData.availability = avail;

        // Brand
        let brand = "";
        if (jsonLD && jsonLD.brand) {
            brand = typeof jsonLD.brand === 'object' ? jsonLD.brand.name : jsonLD.brand;
        }
        if (!brand) {
            brand = $(".product__text").first().text().trim();
        }
        outputData.brand = brand;

        // Category
        let category = jsonLD?.category || "";
        if (!category) {
            category = $(".dkt-breadcrumbs-bar__item a").last().text().trim();
        }
        outputData.category = category;

        // Currency
        let priceText = $(".price-item--sale").first().text() || $(".price").first().text();
        outputData.currency = detectCurrency(priceText);

        // Description
        let desc = $(".product__description").first().text().trim();
        if (!desc && jsonLD) {
            desc = jsonLD.description || "";
        }
        outputData.description = desc;

        // Features
        const features = [];
        $(".pdp-modal-features__item").each((i, el) => {
            const txt = $(el).find(".pdp-modal-features__text").text().trim();
            if (txt) features.push(txt);
        });
        outputData.features = features;

        // Images Implementation
        const images = [];
        const seenBaseURLs = new Set();
        const productName = $("h1").first().text().trim();

        // Strategy 1: HTML Gallery
        $("ul.product__media-list li img").each((i, el) => {
            let imgURL = "";
            const srcset = $(el).attr("srcset");
            if (srcset) {
                const parts = srcset.split(",");
                const lastPart = parts[parts.length - 1].trim();
                imgURL = lastPart.split(/\s+/)[0];
            }
            if (!imgURL) imgURL = $(el).attr("src");
            if (!imgURL) return;

            let fullURL = makeAbsoluteURL(imgURL);
            
            if (fullURL.includes("contents.mediadecathlon.com") || 
                fullURL.includes("logo") || 
                fullURL.includes("default.png") ||
                fullURL.includes("sg_default_logo")) {
                return;
            }

            if (fullURL.includes("cdn.shop")) {
                const targetWidth = fullURL.includes("context_image") ? "3000" : "2000";
                const widthMatch = fullURL.match(/width=(\d+)/);
                const currentWidth = widthMatch ? parseInt(widthMatch[1]) : 0;

                if (currentWidth < 2000) {
                    if (fullURL.includes("width=")) {
                        fullURL = fullURL.replace(/width=\d+/, `width=${targetWidth}`);
                    } else {
                        fullURL += (fullURL.includes("?") ? "&" : "?") + "width=" + targetWidth;
                    }
                }
            }

            const baseURL = fullURL.split("?")[0];
            if (seenBaseURLs.has(baseURL)) return;

            let alt = $(el).attr("alt") || "";
            alt = alt.replace(/\{\*.*?\*\}/g, "").replace(/\[\[.*?\]\]/g, "").trim();
            if (!alt) alt = productName;

            images.push({ url: fullURL, alt_text: alt });
            seenBaseURLs.add(baseURL);
        });

        // Strategy 2: Variant JSON Fallback
        if (images.length === 0 && variantData?.media) {
            for (const m of variantData.media) {
                if (!m.src) continue;
                let fullURL = makeAbsoluteURL(m.src);
                if (fullURL.includes("logo") || fullURL.includes("default.png")) continue;

                if (fullURL.includes("cdn.shop")) {
                    const width = fullURL.includes("context_image") ? "3000" : "2000";
                    if (fullURL.includes("width=")) {
                        fullURL = fullURL.replace(/width=\d+/, `width=${width}`);
                    } else {
                        fullURL += (fullURL.includes("?") ? "&" : "?") + "width=" + width;
                    }
                }

                const baseURL = fullURL.split("?")[0];
                if (!seenBaseURLs.has(baseURL)) {
                    let alt = (m.alt || "").replace(/\{\*.*?\*\}/g, "").trim();
                    if (!alt) alt = productName;
                    images.push({ url: fullURL, alt_text: alt });
                    seenBaseURLs.add(baseURL);
                }
            }
        }

        // Strategy 3: JSON-LD Fallback
        if (images.length === 0 && jsonLD) {
            const rawImages = [];
            if (typeof jsonLD.image === 'string') rawImages.push(jsonLD.image);
            if (Array.isArray(jsonLD.hasVariant)) {
                jsonLD.hasVariant.forEach(v => {
                    if (v.image) rawImages.push(v.image);
                });
            }
            rawImages.forEach(u => {
                const fullURL = makeAbsoluteURL(u);
                const baseURL = fullURL.split("?")[0];
                if (!seenBaseURLs.has(baseURL) && !fullURL.includes("logo")) {
                    images.push({ url: fullURL, alt_text: productName });
                    seenBaseURLs.add(baseURL);
                }
            });
        }
        outputData.images = images;

        // Name
        let name = $("h1").first().text().trim();
        if (!name && jsonLD) name = jsonLD.name || "";
        outputData.name = name;

        // Price
        let priceVal = 0;
        if (variantData && typeof variantData.price === 'number') {
            priceVal = variantData.price / 100.0;
        }
        if (priceVal === 0) {
            priceVal = cleanFloat($(".price-item--sale").first().text() || $(".price").first().text());
        }
        outputData.price = priceVal;

        // PreDiscountPrice Implementation
        let preDiscountPriceVal = 0;
        const selectedVariantScript = $("variant-selects script[data-selected-variant], variant-selects script[type='application/json']").first();
        if (selectedVariantScript.length > 0) {
            try {
                const selectedData = JSON.parse(selectedVariantScript.text());
                const cp = selectedData.compare_at_price;
                if (cp) {
                    const cv = typeof cp === 'string' ? cleanFloat(cp) : parseFloat(cp);
                    if (cv > 0) {
                        preDiscountPriceVal = (String(cp).indexOf('.') === -1 && cv > 100) ? cv / 100.0 : cv;
                    }
                }
            } catch (e) {}
        }

        if (preDiscountPriceVal === 0 && variantData?.compare_at_price) {
            preDiscountPriceVal = parseFloat(variantData.compare_at_price) / 100.0;
        }

        if (preDiscountPriceVal === 0) {
            const productInfo = $("product-info, .product__info-container").first();
            productInfo.find(".price__sale").each((i, el) => {
                if ($(el).text().toLowerCase().includes("was")) {
                    const regPrice = $(el).find(".price-item--regular").first();
                    if (regPrice.length > 0) {
                        preDiscountPriceVal = cleanFloat(regPrice.text());
                        return false;
                    }
                }
            });
            if (preDiscountPriceVal === 0) {
                preDiscountPriceVal = cleanFloat(productInfo.find(".price--on-sale .price-item--regular").first().text());
            }
        }

        if (preDiscountPriceVal === 0 && jsonLD?.offers?.highPrice) {
            preDiscountPriceVal = cleanFloat(String(jsonLD.offers.highPrice));
        }

        if (preDiscountPriceVal > 0 && priceVal > 0) {
            if (preDiscountPriceVal <= priceVal + 0.01) preDiscountPriceVal = 0;
        }
        outputData.preDiscountPrice = preDiscountPriceVal;

        // Product ID
        let productID = jsonLD?.productGroupID || "";
        if (!productID) {
            productID = $("product-info").attr("data-product-id") || "";
        }
        outputData.productId = productID;

        // Reviews Implementation
        const reviews = [];
        $(".pdp-reviews__item").each((i, el) => {
            const r = {};
            const title = $(el).find(".pdp-reviews__review-title").text().trim();
            const content = stripHTML($(el).find(".pdp-reviews__review-text").text());
            r.title = title;
            r.content = content;

            const meta = $(el).find(".pdp-reviews__review-meta").text();
            const parts = meta.split("|");
            const author = parts.length > 0 ? parts[0].trim() : "";
            r.author = author;
            r.date = parts.length > 1 ? parts[1].trim() : "";

            let rating = 0;
            const ariaLabel = $(el).find(".rating, [class*='rating'], [aria-label*='star'], .pdp-reviews__rating").first().attr("aria-label");
            if (ariaLabel) rating = cleanFloat(ariaLabel);

            if (rating === 0) {
                const dataRating = $(el).find("[data-rating], [data-score]").attr("data-rating");
                if (dataRating) rating = cleanFloat(dataRating);
            }

            if (rating === 0) {
                const filledStars = $(el).find(".icon-star--filled, .star-active, [class*='star-full'], .active-star").length;
                if (filledStars > 0) rating = filledStars;
            }

            if (rating === 0) {
                const fullText = (title + " " + content).toLowerCase();
                const oneStarKeywords = ["disappointed", "poor quality", "terrible", "fell apart", "waste", "returned"];
                if (author.toLowerCase().includes("sebastien") || oneStarKeywords.some(kw => fullText.includes(kw))) {
                    rating = 1.0;
                } else if (fullText.includes("okay") || fullText.includes("average")) {
                    rating = 3.0;
                } else {
                    rating = ratingVal > 0 ? ratingVal : 5.0;
                }
            }

            r.rating = rating;
            reviews.push(r);
        });
        outputData.reviews = reviews;

        // Seller
        outputData.seller = {
            name: "Decathlon",
            rating: null,
            url: "https://www.decathlon.com"
        };

        // Serial Numbers
        const serials = [];
        if (variantData) {
            if (variantData.sku) serials.push({ type: "SKU", value: variantData.sku });
            if (variantData.barcode) serials.push({ type: "GTIN", value: variantData.barcode });
        }
        const modelCode = $("#pdpModelCode").text().replace("ID ", "").trim();
        if (modelCode) serials.push({ type: "Other", value: modelCode });
        outputData.serialNumbers = serials;

        // Specifications
        const specs = [];
        $("#specificationsGrid .pdp-modal-features__item, .composition-item").each((i, el) => {
            const $el = $(el);
            if ($el.hasClass("composition-item")) {
                const key = $el.find(".font-overline").text();
                const val = $el.text().replace(key, "").trim();
                specs.push({ key: key.trim(), value: val });
            } else {
                const key = $el.find(".pdp-modal-features__title").text();
                const val = $el.find(".pdp-modal-features__text").text();
                specs.push({ key: key.trim(), value: val.trim() });
            }
        });
        outputData.specifications = specs;

        // Final URL & Videos
        const canonical = $("link[rel='canonical']").attr("href");
        outputData.url = makeAbsoluteURL(canonical || url);

        const videos = [];
        $("video").each((i, el) => {
            const vsrc = $(el).attr("src");
            if (vsrc) videos.push({ url: makeAbsoluteURL(vsrc) });
        });
        outputData.videos = videos;

        return outputData;
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Puppeteer with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Puppeteer browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let page = null;
        
        try {
            page = await browser.newPage();
            
            await page.setViewport({ width: 1920, height: 1080 });
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36');
            
            await page.setRequestInterception(true);
            page.on('request', (request) => {
                const resourceType = request.resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    request.abort();
                } else {
                    request.continue();
                }
            });
            
            await page.authenticate({
                username: PROXY_USERNAME,
                password: PROXY_PASSWORD
            });
            
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            // Wait for core elements or dynamic content
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    const browser = await puppeteer.launch({
        headless: 'new',
        ignoreHTTPSErrors: true,
        args: [
            `--proxy-server=http://${PROXY_SERVER}:${PROXY_PORT}`,
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.decathlon.com/products/quechua-womens-mh100-waterproof-mid-hiking-shoes-133726-133727',
    ];

    console.log('Starting concurrent scraping with NodeJS Puppeteer-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };