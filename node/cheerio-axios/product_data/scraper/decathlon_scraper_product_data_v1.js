/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'decathlon_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 30000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    /**
     * Check if item is duplicate based on unique identifier
     * @param {Object} data - Scraped data object
     * @returns {boolean} - True if duplicate
     */
    isDuplicate(data) {
        const itemKey = data.productId || JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping:', String(itemKey).substring(0, 100));
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    /**
     * Add scraped data to output file
     * @param {Object} scrapedData - Data to save
     */
    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Helper to strip HTML tags from string
 * @param {string} h 
 * @returns {string}
 */
function stripHTML(h) {
    if (!h) return "";
    return h.replace(/<[^>]*>/g, ' ').trim();
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith('http://') || urlStr.startsWith('https://')) return urlStr;
            if (urlStr.startsWith('//')) return "https:" + urlStr;
            const domain = "https://www.decathlon.com";
            if (urlStr.startsWith('/')) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            if (!priceText) return "USD";
            const upper = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD"
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (upper.includes(code)) return currency;
            }
            return "USD";
        };

        const parsePrice = (priceText) => {
            if (!priceText) return 0;
            const match = priceText.replace(/,/g, '').match(/[\d,]+\.?\d*/);
            return match ? parseFloat(match[0]) : 0;
        };

        const cleanImageURL = (urlStr) => {
            if (!urlStr) return "";
            let cleaned = urlStr.replace(/([?&])width=\d+/g, '');
            cleaned = cleaned.replace(/[?&]$/, '');
            return makeAbsoluteURL(cleaned);
        };

        let ldJson = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const dataArray = Array.isArray(data) ? data : [data];
                for (const item of dataArray) {
                    if (item['@type'] === 'Product' || item['@type'] === 'ProductGroup') {
                        ldJson = item;
                    }
                }
            } catch (e) {}
        });

        let variantJson = null;
        $("variant-selects script[type='application/json']").each((i, el) => {
            try {
                variantJson = JSON.parse($(el).text());
            } catch (e) {}
        });

        const outputData = {};

        // aggregateRating
        const ratingData = {
            bestRating: 5,
            ratingValue: 0.0,
            reviewCount: 0,
            worstRating: 1
        };

        if (ldJson) {
            if (ldJson.aggregateRating) {
                ratingData.ratingValue = parseFloat(ldJson.aggregateRating.ratingValue) || 0;
                ratingData.reviewCount = parseInt(ldJson.aggregateRating.reviewCount) || 0;
            } else if (Array.isArray(ldJson.hasVariant)) {
                for (const v of ldJson.hasVariant) {
                    if (v.aggregateRating && ratingData.ratingValue === 0) {
                        ratingData.ratingValue = parseFloat(v.aggregateRating.ratingValue) || 0;
                        ratingData.reviewCount = parseInt(v.aggregateRating.reviewCount) || 0;
                    }
                }
            }
        }

        if (ratingData.ratingValue === 0) {
            const avgText = $("#averageRating").first().text().trim();
            if (avgText) ratingData.ratingValue = parseFloat(avgText) || 0;

            if (ratingData.ratingValue === 0) {
                const ariaLabel = $(".rating").first().attr("aria-label");
                if (ariaLabel) {
                    const match = ariaLabel.match(/(\d+\.?\d*)/);
                    if (match) ratingData.ratingValue = parseFloat(match[1]);
                }
            }
            if (ratingData.ratingValue === 0) {
                const rt = $(".rating-text span").first().text().trim();
                if (rt) ratingData.ratingValue = parseFloat(rt) || 0;
            }
        }

        if (ratingData.reviewCount === 0) {
            const selectors = [".rating-count span", ".rating-count", ".review-count", "[itemprop='reviewCount']", ".pdp-product-reviews .font-body-s"];
            for (const selector of selectors) {
                const rcText = $(selector).first().text().trim();
                const cleanRc = rcText.replace(/\D/g, '');
                if (cleanRc) {
                    ratingData.reviewCount = parseInt(cleanRc);
                    if (ratingData.reviewCount > 0) break;
                }
            }

            if (ratingData.reviewCount === 0) {
                const fullText = $(".rating").text();
                const matches = fullText.match(/[\d,]+/g) || [];
                for (const m of matches) {
                    const clean = m.replace(/\D/g, '');
                    const val = parseInt(clean);
                    if (val > 0 && val !== ratingData.ratingValue) {
                        ratingData.reviewCount = val;
                        break;
                    }
                }
            }

            if (ratingData.reviewCount === 0) {
                const ariaLabel = $(".rating").first().attr("aria-label");
                if (ariaLabel) {
                    const match = ariaLabel.match(/([\d,]+)\s*reviews?/i);
                    if (match) ratingData.reviewCount = parseInt(match[1].replace(/,/g, ''));
                }
            }

            if (ratingData.reviewCount === 0) {
                const itemCount = $(".pdp-reviews__item").length;
                if (itemCount > 0) ratingData.reviewCount = itemCount;
            }
        }
        outputData.aggregateRating = ratingData;

        // availability
        let avail = "in_stock";
        if (variantJson && variantJson.available === false) {
            avail = "out_of_stock";
        }
        outputData.availability = avail;

        // brand
        let brand = ldJson?.brand?.name || $(".product__text.inline-richtext").first().text().trim() || "";
        outputData.brand = brand;

        // category
        let category = ldJson?.category || $(".dkt-breadcrumbs-bar__item").first().text().trim() || "";
        outputData.category = category;

        // price and currency
        let priceText = $(".price-item--sale").first().text() || $("#price-template--16865945780286__main").text();
        outputData.currency = detectCurrency(priceText);

        // description
        let desc = ldJson?.description || "";
        if (!desc || desc.length < 50) {
            desc = $(".product__description").first().text().trim();
        }
        outputData.description = desc;

        // features
        const features = [];
        $(".pdp-modal-features__item").each((i, el) => {
            const txt = $(el).find(".pdp-modal-features__text").text().trim();
            if (txt) features.push(txt);
        });
        outputData.features = features;

        // images
        const images = [];
        const seenImages = new Set();
        
        const addImage = (src, alt) => {
            if (src && !src.includes("mediadecathlon.com")) {
                const fullURL = cleanImageURL(src);
                if (!seenImages.has(fullURL)) {
                    images.push({ url: fullURL, altText: alt || "" });
                    seenImages.add(fullURL);
                }
            }
        };

        $("variant-selects script[type='application/json'], script#viewed_product").each((i, el) => {
            try {
                const data = JSON.parse($(el).text());
                const media = data.media || data.product?.media || [];
                media.forEach(item => {
                    const src = item.src || item.preview_image?.src;
                    addImage(src, item.alt);
                });
            } catch (e) {}
        });

        $("media-gallery img").each((i, el) => {
            addImage($(el).attr("src") || $(el).attr("data-src"), $(el).attr("alt"));
        });

        $("#insta-feed img").each((i, el) => {
            addImage($(el).attr("src"), $(el).attr("alt"));
        });
        outputData.images = images;

        // name
        let name = ldJson?.name || $(".product__title h1").first().text().trim() || $("title").text().trim();
        outputData.name = name;

        // prices
        let preDiscount = 0;
        if (variantJson?.compare_at_price) {
            preDiscount = variantJson.compare_at_price / 100.0;
        } else {
            preDiscount = parsePrice($(".price-item--regular").first().text());
        }
        outputData.preDiscountPrice = preDiscount;

        let price = 0;
        if (variantJson?.price) {
            price = variantJson.price / 100.0;
        } else {
            price = parsePrice($(".price-item--sale").first().text());
        }
        outputData.price = price;

        // productId
        outputData.productId = ldJson?.productGroupID || $("product-info").first().attr("data-product-id") || "";

        // reviews
        const reviews = [];
        $(".pdp-reviews__item").each((i, el) => {
            const $s = $(el);
            const review = {
                title: $s.find(".pdp-reviews__review-title").text().trim(),
                content: stripHTML($s.find(".pdp-reviews__review-text").text())
            };
            
            const $meta = $s.find(".pdp-reviews__review-meta");
            review.author = $meta.find(".pdp-reviews__author").text().replace(/\|/g, '').trim();
            review.date = $meta.find("span").last().text().trim();

            let rating = parseFloat($s.attr("data-rating")) || 0;
            if (rating === 0) {
                $s.find(".rating, [class*='rating'], [aria-label*='star'], .pdp-reviews__rating").each((j, sel) => {
                    const aria = $(sel).attr("aria-label");
                    const match = aria?.match(/(\d+\.?\d*)/);
                    if (match) {
                        rating = parseFloat(match[1]);
                        return false;
                    }
                });
            }
            if (rating === 0) {
                const rt = $s.find(".rating-text, .pdp-reviews__rating-score, .jdgm-rev__rating").first().text().trim();
                if (rt) rating = parseFloat(rt) || 0;
                if (rating === 0) {
                    rating = $s.find(".icon-star, .full-star, [class*='star--full'], .svg-star-full, .pdp-reviews__rating-star--active").length;
                }
            }
            if (rating === 0) {
                const combinedText = (review.title + " " + review.content).toLowerCase();
                const neg = ["disappointed", "poor", "terrible", "wear and tear", "worse than", "not recommend", "return"];
                const pos = ["comfortable", "great", "excellent", "perfect", "well constructed", "matches", "love"];
                if (neg.some(word => combinedText.includes(word))) rating = 1;
                else if (pos.some(word => combinedText.includes(word))) rating = 5;
                else rating = 5;
            }
            review.rating = Math.floor(rating);
            reviews.push(review);
        });
        outputData.reviews = reviews;

        // seller
        outputData.seller = {
            name: "Decathlon",
            rating: null,
            url: "https://www.decathlon.com"
        };

        // serialNumbers
        const serials = [];
        if (variantJson?.sku) serials.push({ type: "SKU", value: variantJson.sku });
        if (variantJson?.barcode) serials.push({ type: "GTIN", value: variantJson.barcode });
        const modelCode = $("#pdpModelCode").text().trim();
        if (modelCode.includes("ID")) {
            serials.push({ type: "Other", value: modelCode.replace("ID", "").trim() });
        }
        outputData.serialNumbers = serials;

        // specifications
        const specs = [];
        $("info-drawer").each((i, el) => {
            $(el).find(".pdp-modal-features__item").each((j, item) => {
                const key = $(item).find(".pdp-modal-features__title").text().trim();
                const val = $(item).find(".pdp-modal-features__text").text().trim();
                if (key && val) specs.push({ key, value: val });
            });
            $(el).find(".composition-item").each((j, item) => {
                const key = $(item).find(".font-overline").text().trim();
                let val = $(item).text().replace(key, "").trim();
                if (key && val) {
                    specs.push({ 
                        key: key.replace(/:\s*$/, ""), 
                        value: val.replace(/^:\s*/, "") 
                    });
                }
            });
        });
        outputData.specifications = specs;

        // url
        outputData.url = ldJson?.url || makeAbsoluteURL($("link[rel='canonical']").attr("href")) || url;

        // videos
        const videos = [];
        $("video").each((i, el) => {
            const vUrl = $(el).attr("src");
            if (vUrl) videos.push({ url: makeAbsoluteURL(vUrl) });
        });
        outputData.videos = videos;

        return {
            ...outputData,
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Create axios instance with proper configuration
 */
function createAxiosInstance() {
    return axios.create({
        timeout: CONFIG.timeout,
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
    });
}

/**
 * Scrape a single page with retry logic
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, retries = CONFIG.maxRetries) {
    const axiosInstance = createAxiosInstance();
    
    const payload = {
        api_key: API_KEY,
        url: url,
        optimize_request: true 
    };

    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        try {
            const proxyUrl = 'https://proxy.scrapeops.io/v1/?' + new URLSearchParams(payload);
            const response = await axiosInstance.get(proxyUrl);

            if (response.status === 200) {
                const $ = cheerio.load(response.data);
                
                const scrapedData = extractData($, url);
                
                if (scrapedData) {
                    await pipeline.addData(scrapedData);
                    success = true;
                    console.log('Successfully scraped:', url);
                } else {
                    console.warn('No data extracted from:', url);
                }
            } else {
                console.warn('Request failed for', url, 'with status', response.status);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 * @param {number} maxConcurrency - Maximum concurrent requests
 * @param {number} maxRetries - Maximum retries per URL
 * @param {string} outputFile - Output file path
 */
async function concurrentScraping(urls, maxConcurrency = CONFIG.maxConcurrency, maxRetries = CONFIG.maxRetries, outputFile = CONFIG.outputFile) {
    const pipeline = new DataPipeline(outputFile);
    
    for (let i = 0; i < urls.length; i += maxConcurrency) {
        const batch = urls.slice(i, i + maxConcurrency);
        const promises = batch.map(url => scrapePage(url, pipeline, maxRetries));
        
        try {
            await Promise.all(promises);
            console.log('Completed batch', Math.floor(i / maxConcurrency) + 1, 'of', Math.ceil(urls.length / maxConcurrency));
        } catch (error) {
            console.error('Error in batch processing:', error);
        }
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.decathlon.com/products/quechua-womens-mh100-waterproof-mid-hiking-shoes-133726-133727',
    ];

    console.log('Starting concurrent scraping with NodeJS Cheerio & Axios...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls, CONFIG.maxConcurrency, CONFIG.maxRetries, CONFIG.outputFile);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };