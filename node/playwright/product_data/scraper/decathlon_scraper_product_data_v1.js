/**
 * Generated by: ScrapeOps AI Scraper Generator on 2026-02-17
 * Signup For Free Beta: https://scrapeops.io/app/register/ai-scraper-generator
 * Docs & Updates: https://scrapeops.io/docs/ai-scraper-generator
 * For Support & Feedback Email: ai-scraper-generator@scrapeops.io
 */

const { chromium } = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const cheerio = require('cheerio');
const fs = require('fs');
const { promisify } = require('util');

// Add stealth plugin
chromium.use(StealthPlugin());

const API_KEY = 'YOUR-API_KEY';

/**
 * Generate output filename with current timestamp
 * @returns {string} Output filename
 */
function generateOutputFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
        (now.getMonth() + 1).toString().padStart(2, '0') +
        now.getDate().toString().padStart(2, '0') + '_' +
        now.getHours().toString().padStart(2, '0') +
        now.getMinutes().toString().padStart(2, '0') +
        now.getSeconds().toString().padStart(2, '0');
    return 'decathlon_com_product_page_scraper_data_' + timestamp + '.jsonl';
}

// ScrapeOps Residential Proxy Configuration
const PROXY_CONFIG = {
    server: 'http://residential-proxy.scrapeops.io:8181',
    username: 'scrapeops',
    password: API_KEY
};

// Configuration
const CONFIG = {
    maxRetries: 3,
    maxConcurrency: 1,
    timeout: 180000,
    outputFile: generateOutputFilename()
};

/**
 * Data pipeline for handling scraped data
 */
class DataPipeline {
    constructor(outputFile = CONFIG.outputFile) {
        this.itemsSeen = new Set();
        this.outputFile = outputFile;
        this.writeFile = promisify(fs.appendFile);
    }

    isDuplicate(data) {
        const itemKey = JSON.stringify(data);
        if (this.itemsSeen.has(itemKey)) {
            console.warn('Duplicate item found, skipping');
            return true;
        }
        this.itemsSeen.add(itemKey);
        return false;
    }

    async addData(scrapedData) {
        if (!this.isDuplicate(scrapedData)) {
            try {
                const jsonLine = JSON.stringify(scrapedData) + '\n';
                await this.writeFile(this.outputFile, jsonLine, 'utf8');
                console.log('Saved item to', this.outputFile);
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }
    }
}

/**
 * Extract structured data from HTML using Cheerio
 * @param {Object} $ - Cheerio instance
 * @param {string} url - Source URL
 * @returns {Object|null} - Extracted data or null
 */
function extractData($, url) {
    try {
        const makeAbsoluteURL = (urlStr) => {
            if (!urlStr) return "";
            if (urlStr.startsWith("http://") || urlStr.startsWith("https://")) return urlStr;
            if (urlStr.startsWith("//")) return "https:" + urlStr;
            const domain = "https://www.decathlon.com";
            if (urlStr.startsWith("/")) return domain + urlStr;
            return domain + "/" + urlStr;
        };

        const detectCurrency = (priceText) => {
            const text = priceText.toUpperCase();
            const currencyMap = {
                "USD": "USD", "US$": "USD", "US $": "USD", "$": "USD",
                "EUR": "EUR", "€": "EUR",
                "GBP": "GBP", "£": "GBP", "GB£": "GBP",
                "JPY": "JPY", "¥": "JPY", "JP¥": "JPY",
                "CAD": "CAD", "CA$": "CAD", "C$": "CAD",
                "AUD": "AUD", "AU$": "AUD", "A$": "AUD",
                "CNY": "CNY", "CN¥": "CNY", "RMB": "CNY",
                "CHF": "CHF", "FR.": "CHF",
                "SEK": "SEK", "KR": "SEK",
                "NZD": "NZD", "NZ$": "NZD",
            };
            for (const [code, currency] of Object.entries(currencyMap)) {
                if (text.includes(code)) return currency;
            }
            return "USD";
        };

        const parsePrice = (priceStr) => {
            if (!priceStr) return 0;
            const match = priceStr.replace(/,/g, "").match(/[\d,]+\.?\d*/);
            return match ? parseFloat(match[0]) : 0;
        };

        const cleanAlt = (alt) => {
            if (!alt) return "";
            let cleaned = alt.trim();
            while (true) {
                let original = cleaned;
                if (cleaned.startsWith("{*")) cleaned = cleaned.substring(2);
                if (cleaned.endsWith("*}")) cleaned = cleaned.substring(0, cleaned.length - 2);
                if (cleaned.startsWith("[[")) cleaned = cleaned.substring(2);
                if (cleaned.endsWith("]]")) cleaned = cleaned.substring(0, cleaned.length - 2);
                cleaned = cleaned.trim();
                if (cleaned === original) break;
            }
            return cleaned;
        };

        // JSON-LD Extraction
        let jsonLD = null;
        $("script[type='application/ld+json']").each((i, el) => {
            try {
                const data = JSON.parse($(el).html());
                if (data["@type"] === "Product" || data["@type"] === "ProductGroup") {
                    jsonLD = data;
                }
            } catch (e) {}
        });

        // Variant JSON Extraction
        let variantData = null;
        $("variant-selects script[type='application/json']").each((i, el) => {
            try {
                variantData = JSON.parse($(el).html());
            } catch (e) {}
        });

        const outputData = {};

        // Aggregate Rating
        let ratingVal = 0.0;
        let reviewCount = 0;
        if (jsonLD && jsonLD.aggregateRating) {
            ratingVal = parseFloat(jsonLD.aggregateRating.ratingValue) || 0;
            reviewCount = parseInt(jsonLD.aggregateRating.reviewCount) || 0;
        }
        if (ratingVal === 0) {
            const ratingText = $(".rating-text span, #averageRating").first().text();
            ratingVal = parseFloat(ratingText.trim()) || 0;
        }
        if (reviewCount === 0) {
            const countText = $(".rating-count span").first().text().replace(/,/g, "");
            const match = countText.match(/\d[\d,]*/);
            reviewCount = match ? parseInt(match[0]) : 0;
        }
        outputData.aggregateRating = {
            bestRating: 5,
            ratingValue: ratingVal,
            reviewCount: reviewCount,
            worstRating: 1
        };

        // Availability
        let avail = "in_stock";
        if (variantData && variantData.available === false) {
            avail = "out_of_stock";
        }
        outputData.availability = avail;

        // Brand
        let brand = "";
        if (jsonLD && jsonLD.brand) {
            brand = jsonLD.brand.name || "";
        }
        if (!brand) {
            brand = $(".product__text.inline-richtext, [itemprop='brand']").first().text().trim();
        }
        outputData.brand = brand;

        // Category
        let category = "";
        if (jsonLD && jsonLD.category) {
            category = jsonLD.category;
        }
        if (!category) {
            category = $(".breadcrumbs__link, [itemprop='category']").last().text().trim();
        }
        outputData.category = category;

        // Currency
        let currency = "USD";
        const priceMeta = $("meta[property='og:price:currency']").attr("content");
        if (priceMeta) {
            currency = detectCurrency(priceMeta);
        } else {
            currency = detectCurrency($(".price-item--sale, .price").first().text());
        }
        outputData.currency = currency;

        // Description
        let description = "";
        const descEl = $(".product__description").first();
        if (descEl.length > 0) {
            description = descEl.text().trim();
        } else if (jsonLD && jsonLD.description) {
            description = jsonLD.description;
        }
        outputData.description = description;

        // Features
        const features = [];
        $("#featuresGrid .pdp-modal-features__item, .product-features__item").each((i, el) => {
            const title = $(el).find(".pdp-modal-features__title").text().trim();
            const text = $(el).find(".pdp-modal-features__text").text().trim();
            if (title && text) {
                features.push(`${title}: ${text}`);
            } else if (text) {
                features.push(text);
            }
        });
        outputData.features = features;

        // Images
        const images = [];
        const seenImages = new Set();

        if (variantData) {
            if (variantData.featured_image && variantData.featured_image.src) {
                const fullUrl = makeAbsoluteURL(variantData.featured_image.src);
                if (fullUrl && !seenImages.has(fullUrl)) {
                    seenImages.add(fullUrl);
                    images.push({
                        url: fullUrl,
                        alt_text: cleanAlt(variantData.featured_image.alt)
                    });
                }
            }
            if (Array.isArray(variantData.images)) {
                variantData.images.forEach(imgSrc => {
                    const fullUrl = makeAbsoluteURL(imgSrc);
                    if (fullUrl && !seenImages.has(fullUrl)) {
                        seenImages.add(fullUrl);
                        images.push({ url: fullUrl, alt_text: "" });
                    }
                });
            }
        }

        $("media-gallery .product__media-list .product__media-item img").each((i, el) => {
            let imgUrl = $(el).attr("src");
            if (!imgUrl || imgUrl.includes("default.png") || imgUrl.includes("icon")) return;

            imgUrl = imgUrl.replace(/[?&]width=\d+/, "");
            const fullUrl = makeAbsoluteURL(imgUrl);
            if (fullUrl) {
                const alt = cleanAlt($(el).attr("alt"));
                const existing = images.find(img => img.url === fullUrl);
                if (existing) {
                    if (!existing.alt_text && alt) existing.alt_text = alt;
                } else if (!seenImages.has(fullUrl)) {
                    seenImages.add(fullUrl);
                    images.push({ url: fullUrl, alt_text: alt });
                }
            }
        });

        if (images.length === 0) {
            const ogImg = $("meta[property='og:image']").attr("content");
            if (ogImg) {
                const fullUrl = makeAbsoluteURL(ogImg);
                images.push({ url: fullUrl, alt_text: "" });
            }
        }
        outputData.images = images;

        // Name
        let name = "";
        if (jsonLD && jsonLD.name) name = jsonLD.name;
        if (!name) name = $(".product__title h1, .font-title-m").first().text().trim();
        outputData.name = name;

        // Prices
        let preDisc = 0;
        if (variantData && variantData.compare_at_price > 0) {
            preDisc = variantData.compare_at_price / 100.0;
        }
        if (preDisc === 0) {
            preDisc = parsePrice($(".price-item--regular").first().text());
        }
        outputData.preDiscountPrice = preDisc;

        let price = 0;
        if (variantData && variantData.price) {
            price = variantData.price / 100.0;
        }
        if (price === 0) {
            price = parsePrice($(".price-item--sale").first().text());
        }
        outputData.price = price;

        // Product ID
        let productID = "";
        if (jsonLD && jsonLD.productGroupID) productID = jsonLD.productGroupID;
        if (!productID) productID = $("product-info").attr("data-product-id") || "";
        outputData.productId = productID;

        // Reviews
        const reviews = [];
        $(".pdp-reviews__item").each((i, el) => {
            const authorFull = $(el).find(".pdp-reviews__author").text().trim();
            const author = authorFull.replace(/\s*\|\s*$/, "").trim();
            const content = $(el).find(".pdp-reviews__review-text").text().trim();
            
            let rating = 0;
            $(el).find(".pdp-reviews__star").each((j, star) => {
                const starText = $(star).text().trim();
                const isActive = $(star).hasClass("is-active") || $(star).hasClass("pdp-reviews__star--filled");
                if (starText === "★" || (starText === "" && isActive)) {
                    rating++;
                }
            });

            reviews.push({
                author,
                content,
                date: $(el).find(".pdp-reviews__review-meta span").last().text().trim(),
                rating,
                title: $(el).find(".pdp-reviews__review-title").text().trim()
            });
        });
        outputData.reviews = reviews;

        outputData.seller = {
            name: "Decathlon",
            rating: null,
            url: "https://www.decathlon.com"
        };

        // Serials
        const serials = [];
        if (variantData) {
            if (variantData.sku) serials.push({ type: "SKU", value: variantData.sku });
            if (variantData.barcode) serials.push({ type: "GTIN", value: variantData.barcode });
        }
        const modelCode = $("#pdpModelCode").text().replace("ID ", "").trim();
        if (modelCode) serials.push({ type: "Other", value: modelCode });
        outputData.serialNumbers = serials;

        // Specifications
        const specs = [];
        $("#materialsGrid .composition-item").each((i, el) => {
            const k = $(el).find(".font-overline").text().trim();
            let v = $(el).text().replace(k, "").trim();
            const key = k.replace(/:$/, "");
            if (key) specs.push({ key, value: v.replace(/^:\s*/, "") });
        });
        $("#specificationsGrid .pdp-modal-features__item").each((i, el) => {
            specs.push({
                key: $(el).find(".pdp-modal-features__title").text().trim(),
                value: $(el).find(".pdp-modal-features__text").text().trim()
            });
        });
        outputData.specifications = specs;

        // URL
        let prodURL = url;
        if (jsonLD && jsonLD.url) prodURL = jsonLD.url;
        if (!prodURL || prodURL === url) prodURL = $("link[rel='canonical']").attr("href") || url;
        outputData.url = prodURL;

        // Videos
        const videos = [];
        const seenVideos = new Set();
        const addVideo = (vurl) => {
            if (!vurl) return;
            let cleanUrl = vurl.replace(/&amp;/g, "&").replace(/\\u0026/g, "&").replace(/\\\//g, "/");
            if (cleanUrl.startsWith("//")) cleanUrl = "https:" + cleanUrl;
            if ((cleanUrl.startsWith("http") || cleanUrl.startsWith("https")) && !seenVideos.has(cleanUrl)) {
                seenVideos.add(cleanUrl);
                videos.push({ url: cleanUrl });
            }
        };

        $("#insta-feed, .insta-feed").find("video, source, img, a, div").each((i, el) => {
            ["src", "data-src", "data-video-src", "href", "data-lazy-src"].forEach(attr => {
                const val = $(el).attr(attr);
                if (val && (val.includes(".mp4") || val.includes("cdninstagram"))) addVideo(val);
            });
        });

        $("video, source").each((i, el) => {
            ["src", "data-src", "data-video-src", "data-lazy-src"].forEach(attr => addVideo($(el).attr(attr)));
        });

        $("[src*='.mp4'], [data-src*='.mp4'], [href*='.mp4']").each((i, el) => {
            addVideo($(el).attr("src") || $(el).attr("data-src") || $(el).attr("href"));
        });

        $("script").each((i, el) => {
            const content = $(el).html();
            if (content.includes(".mp4") || content.includes("cdninstagram")) {
                const matches = content.match(/https?:\/\/[^"'\s]+\.mp4[^"'\s]*/g);
                if (matches) matches.forEach(m => addVideo(m));
            }
        });
        outputData.videos = videos;

        return {
            ...outputData,
            timestamp: new Date().toISOString()
        };
    } catch (error) {
        console.error('Error extracting data from', url, ':', error);
        return null;
    }
}

/**
 * Scrape a single page with retry logic using Playwright with stealth
 * @param {string} url - URL to scrape
 * @param {DataPipeline} pipeline - Data pipeline instance
 * @param {Object} browser - Playwright browser instance
 * @param {number} retries - Number of retries
 */
async function scrapePage(url, pipeline, browser, retries = CONFIG.maxRetries) {
    let success = false;
    let attempts = 0;

    while (attempts <= retries && !success) {
        let context = null;
        let page = null;
        
        try {
            context = await browser.newContext({
                ignoreHTTPSErrors: true,
                viewport: { width: 1920, height: 1080 },
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
            });
            
            page = await context.newPage();
            
            await page.route('**/*', (route) => {
                const resourceType = route.request().resourceType();
                if (['image', 'media', 'font', 'stylesheet'].includes(resourceType)) {
                    route.abort();
                } else {
                    route.continue();
                }
            });
            
            await page.goto(url, { 
                waitUntil: 'domcontentloaded',
                timeout: CONFIG.timeout 
            });
            
            await page.waitForTimeout(1000);
            
            const bodyHTML = await page.evaluate(() => document.body.innerHTML);
            const $ = cheerio.load(bodyHTML);
            
            const scrapedData = extractData($, url);
            
            if (scrapedData) {
                await pipeline.addData(scrapedData);
                success = true;
                console.log('Successfully scraped:', url);
            } else {
                console.warn('No data extracted from:', url);
            }
        } catch (error) {
            console.error('Exception scraping', url, ':', error.message);
            
            if (attempts < retries) {
                const delay = Math.pow(2, attempts) * 1000;
                console.log('Retrying in', delay, 'ms...');
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        } finally {
            if (page) await page.close();
            if (context) await context.close();
            attempts++;
        }
    }

    if (!success) {
        console.error('Failed to scrape', url, 'after', retries, 'retries');
    }
}

/**
 * Scrape multiple URLs concurrently with controlled concurrency
 * @param {string[]} urls - Array of URLs to scrape
 */
async function concurrentScraping(urls) {
    const pipeline = new DataPipeline(CONFIG.outputFile);
    
    const browser = await chromium.launch({
        headless: true,
        proxy: PROXY_CONFIG,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-web-security'
        ]
    });

    try {
        for (let i = 0; i < urls.length; i += CONFIG.maxConcurrency) {
            const batch = urls.slice(i, i + CONFIG.maxConcurrency);
            const promises = batch.map(url => scrapePage(url, pipeline, browser, CONFIG.maxRetries));
            
            try {
                await Promise.all(promises);
                console.log('Completed batch', Math.floor(i / CONFIG.maxConcurrency) + 1, 'of', Math.ceil(urls.length / CONFIG.maxConcurrency));
            } catch (error) {
                console.error('Error in batch processing:', error);
            }
        }
    } finally {
        await browser.close();
    }
}

/**
 * Main execution function
 */
async function main() {
    const urls = [
        'https://www.decathlon.com/products/quechua-womens-mh100-waterproof-mid-hiking-shoes-133726-133727',
    ];

    console.log('Starting concurrent scraping with NodeJS Playwright-Extra + Stealth...');
    console.log('URLs to scrape:', urls.length);
    console.log('Max concurrency:', CONFIG.maxConcurrency);
    console.log('Output file:', CONFIG.outputFile);

    try {
        await concurrentScraping(urls);
        console.log('Scraping completed successfully!');
    } catch (error) {
        console.error('Scraping failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = { extractData, scrapePage, concurrentScraping, DataPipeline };